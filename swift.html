<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>~~Swift~~</title>
        <link rel="stylesheet" href="style/style.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism-okaidia.min.css">
    </head>
    <body>
        <div class="header">
            <!-- そのページの概要 -->
            <h1 class="page-title">~~ Swift ~~</h1>
            <a class="top-link" href="index.html">Back to Top</a>
        </div>
        <div class="main">
            <h3>links</h3>
            <div class="links">
                <ol>
                    <!-- ページ内リンク -->
                    <li><a href="#1">変数</a></li>
                    <li><a href="#2">定数</li>
                    <li><a href="#3">基本的な型</a></li>
                    <li><a href="#4">Optinal型</a></li>
                    <li><a href="#5">型のキャスト</a></li>
                    <li><a href="#6">配列</a></li>
                    <li><a href="#7">タプル</a></li>
                    <li><a href="#8">辞書</a></li>
                    <li><a href="#9">範囲</a></li>
                    <li><a href="#10">if文</a></li>
                    <li><a href="#11">for文</a></li>
                    <li><a href="#12">while文</a></li>
                    <li><a href="#13">関数</a></li>
                </ol>
            </div>
            <br>
            <br>
            <br>
            <!-- コンテンツ -->
            <div class="contents" id="1">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">変数</h2>
                <p>
                    変数とは値を保存するための箱のようなもので、変数に値を入れることで
                    値を再利用できます。<br>
                    また、Swiftは<span style="font-size: 1.1em; color: black;">静的型付け言語</span>のため、
                    型宣言時に<a href="#3">型</a>を指定してあげなくてはいけません。
                    その変数の型に一致しない値を代入しようとした場合、コンパイルエラーとなってしまいます。
                    一方で変数に静的な型は存在せず、代入された値によってその変数の型が決まる言語のことを
                    <span style="font-size: 1.1em; color: black;">動的型付け言語</span>といい、代表的なものではPythonが挙げられます。
                </p>
                <strong>具体的な宣言方法</strong>
                <pre><code class="language-javascript">
// var 変数名:型 = 値
var num:Int = 10
                </code></pre>
                <p>
                    また、変数や<a href="#2">定数</a>の宣言時に型を宣言しなくても、<span style="font-size: 1.1em; color: black;">型推論</span>
                    という機能によって自動的に型が振り分けられます。<br>
                    しかし、型推論を利用するためには、変数宣言時に値を代入している必要があります。
                </p>
                <p>
                    ここでは、Int型の変数numを宣言しています。<br>
                    型については後で触れています。<br>
                </p>
                <p>その他の変数同士の演算や、代入、などは割愛します。</p>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="2">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">定数</h2>
                <p>
                    定数とはほとんど<a href="#1">変数</a>と同じ機能を持っています。
                    唯一違う点は、<span style="font-size: 1.1em; color: black;">再代入</span>できない
                    という違いです。一度値を持たされた定数に再度値を代入するとコンパイルエラーとなってしまいます。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// let 定数名:型名 = 値
let num:Int = 12
                </code></pre>
                <p>ここでこの定数numに値を再代入すると...</p>
                <img src="img/teisuu.png" style="height:100%; width:100%;">
                <p>コンパイルエラーとなってしまいます。</p>

            </div>
            <!-- コンテンツ -->
            <div class="contents" id="3">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">基本的な型</h2>
                <p>Swiftが取り扱う基本的な型は以下の通りです。</p>
                <table style="margin-left: 50px;">
                    <tr>
                        <th>型名</th><th>概要</th>
                    </tr>
                    <tr>
                        <td><a href="#1_1">Int</a></td><td>整数値を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_2">String</a></td><td>文字列を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_3">Double</a></td><td>64ビット浮動小数値を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_4">Float</a></td><td>32ビット浮動小数値を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_5">Boolean</a></td><td>真偽値を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_6">Any</a></td><td>全ての値を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_7">Void</a></td><td>値が何も存在しない状態を扱う</td>
                    </tr>
                </table>
                <p>
                    概要に書いてあるとおり、それぞれで扱うことのできる値が変わってきます。
                    またそれぞれの型にOptional型というものがあり、詳しくは次のセクションで
                    解説しています。
                </p>
                <p>
                    その値が何の型なのかを調べるときには
                </p>
                <pre><code class="language-javascript">
print(type(of: 任意の値))
                </code></pre>
                <p>を実行することで、その値の型を調べることができます。</p>
                <strong>結果↓</strong>
                <div class="code-result">
                    <img src="img/type.png" style="height: 50%; width: 50%;">
                </div>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="4">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">Optional型</h2>
                <p>
                    Optional型とは何も値が入っていない状態(nil値)を許容する型です。
                    通常の型にnil値を入れるとコンパイルエラーとなってしまうため、
                    nil値が入ると思われるところに使用します。
                </p>
                <p>
                    Optional型として<a href="#1">変数</a>・<a href="#2">定数</a>を宣言する場合は
                    Optinal&lt;型名&gt;もしくは型名?とすることで宣言できます。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var optionalNum:Optional&lt;Int&gt; = 12
let optionalStr:String? = nil
                </code></pre>
                <p>
                    ただしOptional型はnil値を許容しているため、演算をすることができません。
                    そこで、演算を行うためにはOptional型から値を取り出す<span style="font-size: 1.1em; color: black;">アンラップ</span>
                    を行う必要があります。
                </p>
                <p>アンラップの方法には以下の3つがあります。</p>
                <ul>
                    <li>if-let文を使ったアンラップ</li>
                    <li>??演算子を使ったアンラップ</li>
                    <li>強制アンラップ</li>
                </ul>
                <br>
                <h3>if-let文を使ったアンラップ</h3>
                <p>
                    if-let分を使用することでOptional型をアンラップすることができます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
let opInt:Optional&lt;Int&gt; = 12

// if let 変数名 = Optional型の変数
if let int = opInt{
    // アンラップ成功時に実行したい処理
}
                </code></pre>
                <p>
                    ここでアンラップした先の変数intのスコープはif-let文内となるため、文の外では利用できません。<br>
                    (スコープとはその変数にアクセスできる範囲のこと)
                </p>
                <p>
                    また、通常の<a href="#10">if文</a>と同じく、文末にelseを追加することで、アンラップに失敗したときの処理を
                    追加することができます。
                </p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
let opStr:Optional&lt;String&gt; = nil

if let str = opStr{
    // アンラップ成功時の処理
}else{
    // アンラップ失敗時の処理
}
                </code></pre>
                <br>
                <h3>??演算子を使ったアンラップ</h3>
                <p>
                    アンラップ先の変数・定数宣言時に??演算子を用いることでアンラップを行うことができます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var opInt:Optional&lt;Int&gt; = 12
// var 変数名:型名 Optional型の変数 ?? アンラップしたい型の具体的な値 
var int:Int = opInt ?? 0
print(int)  // 12

opInt = nil
int = opInt ?? 100
print(int)  //100
                </code></pre>
                <p>
                    ??演算子を使ったアンラップは、Optional型の値がnil値でない場合は
                    アンラップされた値が代入され、nil値の場合は??演算子のうしろについている
                    具体的な値が代入されます。これにより、代入先にnil値が入らないことを
                    保証しています。
                </p>
                <br>
                <h3>強制アンラップ</h3>
                <p>
                    強制アンラップとは、Optioanl型にnil値が入っている状態を考えず、すぐに
                    アンラップを行う手法です。<br>
                    強制アンラップはOptional型の変数の後ろに「!」をつけることで行えます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var a:Optional&lt;Int&gt; = 12
var b:Optional&lt;Int&gt; = 2

print(a! + b!)  //14
                </code></pre>
                <p>
                    このように、Optional型の変数から直接値を取り出せます。<span style="font-size: 1.1em; color: black;">しかし</span>
                    この方法はOptional型の変数がnil値だった場合エラーとなる危険性があるので、使う場面をより慎重に考え、
                    適切に使用しなければなりません。乱用は避けましょう。
                </p>
                <p>nil値が入っているときに、強制アンラップを行った場合</p>
                <!-- 画像を入れる -->
                <img src="img/anrappu.png" style="width: 100%;">
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="5">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">型のキャスト</h2>
                <p>
                    キャストとは現在の型を別の型として扱う手法のことを言い、
                    <span style="font-size: 1.1em; color: black;">アップキャスト</span>と
                    <span style="font-size: 1.1em; color: black;">ダウンキャスト</span>の二つがあります。
                </p>
                <br>
                <h3>アップキャスト</h3>
                <p>
                    アップキャストとは階層関係にある具体的な値を、上位の抽象的な値に変換することを言います。
                    キャストには「as」を使用します。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var str:String = "aaa"      // 具体的な型(String)
var any:Any = str as Any    // 上位の抽象的な型(Any)
                </code></pre>
                <h3>ダウンキャスト</h3>
                <p>
                    もう一つのダウンキャストは、アップキャストとは反対に上位の抽象的な
                    型を下位の具体的な型に変換することを言います。また、ダウンキャストされた値は
                    オプショナル型となります。キャストには「as?」「as!」を使用します。
                    しかし、「as!」はダウンキャストと同時に<span style="font-size: 1.1em; color: black;">強制アンラップ</span>を行うため、
                    キャスト元にnil値が入っているとエラーとなります。扱いには注意が必要です。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var any:Any = 12                // 抽象的な型
var opInt:Int? = any as? Int?   // Optinal(12)

any = nil

opInt = any as? Int?            //nil
var int:Int = any as! Int       // キャストもとにnil値が入っているのでエラー
                </code></pre>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="6">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">配列</h2>
                <p>
                    配列とは、変数の寄せ集めのような構造のデータです。
                    使用方法はPythonやほかの言語と大差ないが、宣言方法が独特であります。
                    <a href="#10">for文</a>と組み合わせて使用することもできます。
                    Optional型として宣言することも可能です。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名:Array&lt;任意の型名&gt; = [値, 値, 値.....]
var numArray:Array&lt;Int&gt; = [1, 2, 3, 4, 5, 6]

print(numArray[2])  // 3
                </code></pre>
                <p>他にも「追加」「挿入」「結合」「削除」が可能です。</p>
                <br>
                <h3>追加</h3>
                <p>配列.append(値)で指定した配列に値を追加することができます。</p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 配列.append(値)
var opStrArray:Array&lt;String?&gt; = ["A", "B", "C", "E"]
opStrArray.append(nil)  // ["A", "B", "C", "E", nil]
                </code></pre>
                <br>
                <h3>挿入</h3>
                <p>配列.insert(値, at:インデックス)で、指定した配列の指定したインデックスに値を追加することができます。</p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 配列.insert(値, at:インデックス)
var anyArray:Array&lt;Any&gt; = [1, "aa", 1.5, True]
anyArray.insert(2, at:1)    // [1, 2, "aa", 1.5, True]
                </code></pre>
                <br>
                <h3>結合</h3>
                <p>
                    配列 + 配列とすることで配列同士を結合することができます。感覚的には文字列結合に近いです。<br>
                    ※型は統一されていないとエラーとなってしまいます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 配列 + 配列
var array1 = [1, 2, 3, 4]
var array2 = [6, 7, 8, 9]

var array3 = array1 + array2
print(arrray3)  // [1, 2, 3, 4, 6, 7, 8, 9]
                </code></pre>
                <br>
                <h3>削除</h3>
                <p>配列.remove(at:インデックス)とすることで指定した配列の指定したインデックスの値を削除することができます。</p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 配列.remove(at:インデックス)
var opIntArray: Array&lt;Optional&lt;Int&gt;&gt; = [1, 2, nil, 4]
opIntArray.remove(at: 2)    // [1, 2, 4]
                </code></pre>
                <p>
                    また、配列の中のすべての要素を削除したい場合は配列.removeAll()と
                    することで、インデックスを指定せずにすべての要素を削除することができます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 配列.removeAll()

var array:Array&lt;Int?&gt; = [1, 3, 4, nil, 5]
array.removeAll()       // []
                </code></pre>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="7">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">タプル</h2>
                <p>
                    タプルとは配列のように複数の値を一つの変数、または定数で
                    扱えるようにしたものです。また、配列と違い、複数の型を
                    一つのまとまりとして扱うことができます。しかし、一方で
                    値の追加や削除、繰り返しの処理はできません。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名: (型名, 型名, 型名....) = (値, 値, 値.....)
var tuple: (Int, String) = (1, "A")
                </code></pre>
                <br>
                <p>
                    基本は上のように宣言しますが、宣言の方法を変えることで、
                    値にラベルをつけることができます。
                </p>
                <strong>宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名: (ラベル名:型名, ラベル名:型名, ラベル名:型名....) = (値, 値, 値.....)
var tuple: (number:Int, Name:String) = (1, "A")
                </code></pre>
                <br>
                <p>
                    タプルのメリットは、複数の型を同時に扱えるところにあります。
                    後に紹介する関数で、一度に複数の値を返り値として戻したいとき
                    などに重宝されます。
                    また、値のアクセスには「変数名.要素番号」を使用します。要素番号は
                    配列と同じく「0」から始まります。さらに、
                    ラベル付きだった場合は「変数名.ラベル」とすることでアクセスすることが
                    できます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var tuple: (Int, String) = (1, "A")
var labelTuple:(number:Int, name:String) = (2, "B")

// 変数名.要素番号
print(tuple.1)      // A

// 変数名.ラベル
print(labelTuple.number)    // 2
                </code></pre>
                <br>
                <p>
                    値の更新は「変数名.要素番号 = 新しい値」とすることで更新できます。
                    また、ラベル付きの場合は要素番号の代わりにラベルを指定しても更新できます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var tuple: (Int, String) = (1, "A")
var labelTuple:(number:Int, name:String) = (2, "B")

tuple.1 = "AA"
print(tuple)    // (1, "AA")

labelTuple.number = 200
print(labelTuple)   // (number: 200, name: "B")
                </code></pre>
            </div>
            <div class="contents" id="8">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">辞書</h2>
                <p>
                    辞書とは、キーとそのキーに対応した値を集めたデータのことを言います。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名:Dictionaly&lt;キーの型, 値の型&gt; = [キー:値, キー:値, キー:値...]
var dict:Dictionaly&lt;Int, String&gt; = [1 : "佐藤", 2 : "鈴木", 3 : "田中"]
                </code></pre>
                <p>
                    辞書のキーを指定することで、それに対応した値を取り出すことができます。
                    この取り出した値は、<a href="#4">Optional型</a>となって返ってきます。また、存在しない
                    キーを指定した場合は、nil値が返ってきます。Optional型である理由は
                    ここにあるのかもしれないです。
                </p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 辞書名[キー]
var dict:Dictionaly&lt;Int, String&gt; = [1 : "佐藤", 2 : "鈴木", 3 : "田中"]

var opName:Optional&lt;String&gt;
opName = dict[2]     // Optional("鈴木")
opName = dict[9]     // nil
                </code></pre>
                <p>また、辞書にも「追加」「更新」「削除」の機能があります。</p>
                <br>
                <h3>追加</h3>
                <p>値を追加したい場合は存在しないキーに値を代入します。</p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 辞書名[存在しないキー] = 追加したい値
var dict:Dictionaly&lt;Int, String&gt; = [1 : "佐藤", 2 : "鈴木", 3 : "田中"]

dict[4] = "高橋"
print(dict)     // [1 : "佐藤", 2 : "鈴木", 3 : "田中", 4 : "高橋"]
                </code></pre>
                <br>
                <h3>更新</h3>
                <p>
                    値を更新したい場合は更新したい値に対応したキーを指定して、そこに
                    代入を行います。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 辞書[更新したい値のキー] = 値

var dict:Dictionaly&lt;Int, String&gt; = [1 : "佐藤", 2 : "鈴木", 3 : "田中"]
dict[2] = "渡辺"
print(dict)     // [1 : "佐藤", 2 : "渡辺", 3 : "田中"]
                </code></pre>
                <br>
                <h3>削除</h3>
                <p>
                    辞書の値を削除したいときは、削除したい値に対応したキーを指定して、そこに
                    nil値を代入することで、キーごと辞書から削除することができます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 辞書[削除したい値のキー] = nil

var dict = [1 : "佐藤", 2 : "鈴木", 3 : "田中"]
dict[2] = nil
print(dict)     // [1 : "佐藤", 3 : "田中"]
                </code></pre>
                <p>
                    また、配列と同様に、すべての値を削除したい場合は辞書.removeAll()
                    とすることで、すべてのキーと値を削除することができます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 辞書.removeAll()

var dict = [1 : "佐藤", 2 : "鈴木", 3 : "田中"]
dict.removeAll()

print(dict)     // [:]
                </code></pre>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="9">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">範囲</h2>
                <p>
                    範囲型とはその名の通り一定の範囲を表すことのできる型です。
                    用途としては、ある数値がその範囲内に存在するかを調べたり、
                    <a href="#11">for文</a>とあわせて使ったりします。
                    また、範囲型にはさまざまな範囲を表す型があるので、覚えるのが
                    大変でした。以下が範囲型の一覧です。
                </p>
                <ul>
                    <li><a href="#9_1">Range</a></li>
                    <li><a href="#9_2">CountableRange</a></li>
                    <li><a href="#9_3">ClosedRange</a></li>
                    <li><a href="#9_4">CountableClosedRange</a></li>
                    <li><a href="#9_5">PartialRangeFrom</a></li>
                    <li><a href="#9_6">CountablePartialRangeFrom</a></li>
                    <li><a href="#9_7">PartialRangeUpto</a></li>
                    <li><a href="#9_8">PartialRangeThrough</a></li>
                </ul>
                <br>
                <h3 id="9_1">Range</h3>
                <p>
                    Range型は以上~未満の範囲を表します。型には「Int」
                    「Double」「Float」が指定できます。
                    また、型にIntを指定した場合、勝手に<a href="#9_2">CountableRange</a>
                    となります。
                    Range型はカウント不可なので、for文と組み合わせて使用することga
                    できません。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名:Range&lt;型名&gt; = 始まりの数値..&lt;終わりの数値
var range:Range&lt;Double&gt; = 1.2..&lt;5.5    // 1.2 ~ 5.49999999...までの範囲を表す
                </code></pre>
                <br>
                <h3 id="9_2">CountableRange</h3>
                <p>
                    CountableRange型は名前にもある通り、カウントできるRange型です。
                    指定できる型は、先ほども記述したように、Int型のみとなってます。
                    カウント可能なので、for文と組み合わせて使用することができます。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名:CountableRange&lt;Int&gt; = 始まりの数値..&lt;終わりの数値
var range:CountableRange&lt;Int&gt; = 0..&lt;10     // 0 ~ 9までの範囲を表す
                </code></pre>
                <br>
                <h3 id="9_3">ClosedRange</h3>
                <p>
                    CountableRange型は以上~その数値までの範囲を表します。
                    型には「Int」「Double」「Float」が指定できます。
                    また、型にIntを指定した場合、勝手に<a href="#9_4">CountableClosedRange</a>
                    となります。
                    ClosedRange型はカウント不可なので、for文と組み合わせて使用することはできません。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名:ClosedRange&lt;型名&gt; = 始まりの数値...終わりの数値
var range:ClosedRange&lt;Float&gt; = 1.0...4.9  // 1.0 ~ 4.9までの範囲を表す
                </code></pre>
                <br>
                <h3 id="9_4">CountableClosedRange</h3>
                <p>
                    CountableClosedRange型はClosedRange型のカウント可能版の型です。
                    カウント可能なので、for文と組み合わせて使用することができます。
                    また、指定できる型はInt型のみです。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// let 定数名:CountableClosedRange&lt;Int&gt; = 始まりの数値...終わりの数値
let range:CountableClosedRange&lt;Int&gt; = 0...10  //0 ~ 10までの範囲を表す
                </code></pre>
                <br>
                <h3 id="9_5">PartialRangeFrom</h3>
                <p>
                    PartialRangeFrom型はその数値以上の範囲を表します。
                    型には「Int」「Double」「Float」が指定できます。
                    また、型にIntを指定した場合、勝手に<a href="#9_6">CountablePartialRangeFrom</a>
                    となります。
                    PartialRangeFrom型はカウント不可なので、for文と組み合わせて
                    使用することはできません。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名:PartialRangeFrom&lt;型名&gt; = 始まりの値...
var range:PartialRangeFrom&lt;Double&gt; = 0.2...   // 0.2以上の範囲を表す
                </code></pre>
                <br>
                <h3 id="9_6">CountablePartialRangeFrom</h3>
                <p>
                    CountablePartialRangeFrom型はPartialRangeFrom型の
                    カウント可能版です。カウントが可能なのでfor文と組み合わせて使用できますが、
                    終わりの境界が存在しないため、無限ループとなります。
                    また、指定できる型はInt型のみです。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// let 定数名:CountablePartialRangeFrom&lt;Int&gt; = 始まりの数値...
let range:CountablePartialRangeFrom&lt;Int&gt; = 100... // 100以上の範囲を表します
                </code></pre>
                <br>
                <h3 id="9_7">PartialRangeUpto</h3>
                <p>
                    PartialRangeUpto型はその数値未満の範囲を表します。
                    型には「Int」「Double」「Float」が指定できます。
                    また、この型はカウント不可なのでfor文と組み合わせて使用することができません。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名:PartialRangeUpto&lt;型名&gt; = ..&lt;終わりの数値
var range:PartialRangeUpto&lt;Int&gt; = ..&lt;10    // 9.999999999..までの範囲を表す
                </code></pre>
                <br>
                <h3 id="9_8">PartialRangeThrough</h3>
                <p>
                    PartialRangeThrough型はその数値以下の範囲を表します。
                    型には「Int」「Double」「Float」が指定できます。
                    また、この型はカウント不可なのでfor文と組み合わせて使用することができません。
                </p>
                <strong>具体的な宣言方法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// let 定数名:PartialRangeThrough&lt;型名&gt; = ...終わりの数値
let range:PartialRangeThrough&lt;Double&gt; = ...102.7  // 102.7までの範囲を表す
                </code></pre>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="10">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">if文</h2>
                <p>
                    if文とは分岐を扱うための制御構文です。
                    処理の内容は他の言語と大きな違いはないので、
                    すんなり入ってきました。Pythonとの違いを言えば
                    「:」ではなく「{}」で領域を決めるということです。
                    Javaと似ています。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// if 条件式 {
//      条件成立時に実行したい処理 
// }

var num:Int = 12

if num &gt; 10{
    print("numは10より大きい数です。")  // 実行される
}

if num &lt; 10{
    print("numは10より小さい数です。")  // 実行されない
}
                </code></pre>
                <br>
                <p>
                    if文の後ろに記述する条件式は、実行時にtrueまたはfalseの値に変化します。
                    そのため、ifの後ろに条件式ではなく、直接Boolean型の値を記述してもif文は
                    成立します。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// if Boolean型{
// true時に実行したい処理
// }else{
// false時に実行したい処理
// }

if true{
print("trueが入力されました")   // 実行される
}else{
print("falseが入力されました")  // 実行されない
}

let flg: Boolean = false

if flg{
print("trueが入力されました")   // 実行されない
}else{
rint("falseが入力されました")  // 実行される
}
                </code></pre>
            </div>
            <div class="contents" id="11">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">for文</h2>
                <p>
                    for文とは繰り返しを行うための制御構文で、
                    <a href="#6">配列</a>や<a href="#8">辞書</a>、<a href="9">範囲</a>とよく組み合わせて使用されます。
                    また、範囲型を使用する場合は<span style="font-size: 1.1em; color: black;">カウント可能</span>
                    な型でないといけません。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
let range:CountableRange&lt;Int&gt; = 0..&lt;5     // 範囲型
let array:Array&lt;String&gt; = ["あいうえお", "かきくけこ", "さしすせそ"]
var dict:Dictionary<Int, String> = [1:"田中", 2:"高橋", 3:"佐藤", 4:"鈴木"]

// 範囲型の場合
for i in range{
    print(i)    // 0 ~ 4までの数値が出力される
}

// 配列の場合
for s in array{
    print(s)
    // あいうえお
    // かきくけこ
    // さしすせそ
    // 要素を一つづつ取り出すことができる
}

// 辞書の場合
for data in dict{
    print(i)
    // (key: 2, value: "高橋")
    // (key: 3, value: "佐藤")
    // (key: 4, value: "鈴木")
    // (key: 1, value: "田中")
}

for (key, value) in dict{
    print("key: \(key), value: \(value)")
    // key: 2, value: 高橋
    // key: 1, value: 田中
    // key: 4, value: 鈴木
    // key: 3, value: 佐藤
}
                </code></pre>
                <p>
                    このようにfor文に渡す型の違いによっておおきく
                    挙動が変わります。特に個人的に辞書をfor文に渡したときの
                    挙動がいちばん掴みにくいなと思いました。
                    辞書を変数が一つのfor文に渡した場合、(key:型, value:型)の
                    <a href="#7">タプル型</a>が取得できます。また、得られたタプルは
                    順番通りに並んでない場合があります。
                </p>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="12">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">while文</h2>
                <p>
                    繰り返しを扱う文は上で記述したfor文ともう一つwhile文と
                    いうものがあります。while文はfor文とちがい、直後に
                    条件式を記述し、条件がtrueの場合繰り返しが実行されるといった
                    ものです。また、直接Bool型の値を指定することで繰り返しを行うこともできます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var a:Int = 0

// 0 ~ 9までの数値を表示する繰り返し
while a &lt; 10{
    print(a)
    a += 1
}

var flg:Boolean = true
var b:Int = 0

// Bool型を直接指定した場合
while flg{
    print(b)
    b += 1
    if b &gt; 9{
        flg = false
    }
}
                </code></pre>
                <p>
                    また、while文とfor文の大きな違いとして、無限ループの危険性が
                    while文にはあるといったことが挙げられます。無限ループとは
                    while文の条件が常にtrueとなることで、繰り返しから抜け出せなくなること
                    をいいます。無限ループに陥ると処理が滞り、また、膨大な計算量となってしまう
                    ため、クラッシュの原因になります。そのため、while文には条件に使用する
                    値を変化させなければなりません。
                </p>
                <img src="img/henka.jpg" style="width:100%">
                <p>
                    上の画像のように値を変化させるプログラムを用意し、
                    条件がいずれfalseになるようにすることで
                    無限ループを防ぐことができます。
                </p>
                <p>
                    さらに、ループを途中で終了させたり、飛ばして処理を行いたい場合は
                    breakやcontinueを使用することで、実現できます。
                </p>
                <ul>
                    <li><a href="#12_1">break</a></li>
                    <li><a href="#12_2">continue</a></li>
                </ul>
                <br>
                <h3 id="12_1">break</h3>
                <p>
                    break文は繰り返しの途中で繰り返しを終了させるものです。
                    break文が実行された後の繰り返しのプログラムは実行されず、
                    繰り返しの外に出ます。
                </p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var a:Int = 0

while a &lt; 10{
    if a == 5{
        break
    }
    print(a)
    a += 1
}
print("繰り返し終了")
                </code></pre>
                <p>
                    上のプログラムは本来、0 ~ 9までの数値を表示するプログラムですが、
                    break文を付け足すことで、4が表示されると次は"繰り返し終了"と
                    表示されます。このようにbreak文は実行された時点で、繰り返しを終了し
                    次の処理へと進みます。
                </p>
                <br>
                <h3 id="12_2">continue</h3>
                <p>
                    continue文は繰り返しの処理を飛ばして再度最初から繰り返し処理を行う
                    ものです。文章で見ると意味が捉えにくいので、プログラムで見てみましょう。
                </p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var a:Int = 0

while a &lt; 10{
    if a % 2 == 1{
        a += 1
        continue
    }
    print(a)
    a += 1
}
                </code></pre>
                <p>
                    このプログラムの実行結果は「0, 2, 4, 6, 8」というような結果になります。
                    これはa÷2の余りが1の時にcontinueが実行されているからです。
                    このようにcontinueが実行された時点で、それ以下にある繰り返し内の処理は
                    すっ飛ばされ、繰り返しの先頭から、再度処理が行われます。
                </p>
                <p>
                    また、for文やwhileにラベルをつけることで、breakやcontinueを
                    実行する相手を指定することができます。
                    ラベルとはそのブロックを表す名前のようなものです。
                </p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// ラベル: for
// または
// ラベル: while

// ラベルなし
for i in [0, 1, 2]{
    for j in [0, 1, 2]{
        print("i:\(i), j:\(j)")
        break
        // 結果
        // i:0, j:0
        // i:1, j:0
        // i:2, j:0
    }
}

// ラベルあり
label1: for i in [0, 1, 2]{
    for j in [0, 1, 2]{
        print("i:\(i), j:\(j)")
        break label1
        // 結果
        // i:0, j:0
    }
}
                </code></pre>
                <p>
                    上のプログラムの実行結果からもわかるように、breakで何も指定しない場合は
                    直前の繰り返しから抜け出せないのに対し、ラベルを指定することで、
                    任意の繰り返しから抜け出すことができるようになります。
                </p>
            </div>
            <div class="contents" id="13">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">関数</h2>
                <p>
                    関数とは、一つの処理をまとまりとして管理する方法です。
                    これを使用することで、似たような処理を一箇所で管理することが
                    できるようになるため、修正やコードを記述する時間を短縮することが
                    できます。今までに使用してきた「print()」や「type()」なども
                    関数の一つです。関数に渡す処理に必要な値を「引数」,関数で処理を行った
                    結果の値を「戻り値」と言います。関数を使用する場合は「関数名(引数)」
                    とすることで使用することができます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// func 関数名(引数名: 型, 引数名: 型,...) -&gt; 戻り値の型{
//      ここに行いたい処理を記述する
//      return 戻り値
//}

// 渡された値(引数)に10を足して返す関数
func addTen(num: Int) -&gt; Int{
    let resultNum = num + 10
    return resultNum
}

let result = addTen(num: 5)
print(result)   // 15
                </code></pre>
                <p>
                    上のプログラムでは、一つしか引数はありませんが、複数の引数を用意することもできます。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 引数が複数だった場合
// 引数1の引数2乗する関数
func power(num1:Int, num2:Int)-&gt;Int{
    var powNum:Int = 1

    for _ in 0..&lt;num2{
        powNum *= num1
    }

    return powNum
}

print(power(num1:2, num2:10))   // 1024
                </code></pre>
                <p>
                    このように、宣言時に引数を複数用意してあげれば、関数に複数の値を渡すことができます。
                    ここで、プログラマにとってとてもめんどくさいことがあります。それは、関数呼出時の
                    <span style="font-size: 1.1em; color: black;">引数名の記述</span>です。
                    今のプログラムでは引数の数だけ「関数名(引数名:値, 引数名:値, 引数名:値...)」といったように引数名を記述する
                    必要があります。とてもめんどくさいです。それを解決する方法が、引数名の省略です。
                    省略する方法は以下の通りです。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 引数名の省略
// 関数名(_ 関数内で使用する変数名:型)
func double(_ num:Int)->Int{
    return num * 2
}

print(double(8))    // 16
                </code></pre>
                <p>
                    このように関数内で使用する変数名の前に「_」を記述することで、引数名の省略を
                    行うことができます。また、「_」の代わりに任意の変数名を記述することで、引数名と
                    関数内で使用する変数名を意図して分けることができます。
                </p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 「_」の代わりに変数名を記述した場合
// (引数名 関数内で使用する変数名:型)
func power(coefficient i:Int, index j:Int)-&gt;Int{
    let range:CountableRange&lt;Int&gt; = 0..&lt;j

    var result:Int = 1
    for _ in range{
        result *= i
    }
    return result
}

print(power(coefficient: 10, index: 2)) // 100
                </code></pre>
                <p>
                    このようにすることで、引数名と関数内の変数名を区別することができます。
                    また、関数使用時の予測には、先に記述した引数名が表示されます。
                </p>
                <img src="img/hikisuu.png" style="width:100%">
                <h3>引数のデフォルト値</h3>
                <p>
                    今までに記述してきたプログラムは、引数に必ず値を渡さなければエラーとなってしまいます。
                    また、特に変化しない値を引数で管理する場合もあります。
                </p>
                <p>※引数を渡し忘れていた場合のエラー</p>
                <img src="img/hikisuu_error.png" style="width:100%">
                <p>
                    これらを解決するために引数には、
                    <span style="font-size: 1.1em; color: black;">デフォルト値</span>というものが
                    存在します。
                </p>
                <strong>文法</strong>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 関数名(引数名:型 = デフォルト値)
func power(coefficient:Int, index:Int = 2)-&gt;Int{
    let range = 0..&lt;index

    var result:Int = 1
    for _ in range{
        result *= coefficient
    }
    return result
}

print(power(coefficient: 4))    // 16
print(power(coefficient: 2, index: 10)) // 1024
                </code></pre>
                <p>
                    上のプログラムでは累乗の指数とする引数「index」にデフォルト値の「2」
                    を設定しています。そのため、最初の呼び出しでは、引数が「coefficient」のみの
                    場合でもエラーとならず実行することができます。
                    また、呼び出し時に、デフォルト値が設定されている引数に、新たな引数を渡すことで
                    引数を上書きすることができます。
                    さらに、デフォルト値を設定することで、関数の候補には、デフォルト値の引数を再定義する場合と
                    再定義しない場合の候補が挙げられます。
                </p>
                <p>候補例</p>
                <img src="img/hikisuu_defo.png" style="width:100%">
            </div>
        </div>
        <div class="footer">
            <p>
                荒川 歩夢<br>
                ayumu arakawa
            </p>
            <br>
            <p>
                KCS鹿児島情報専門学校 / 北海道情報大学通信教育部経営情報学部システム情報科<br>
                出身地 : 鹿児島
            </p>
            <p><a href="https://github.com/a-im12" style="color: white;">github : a-im12</a></p>
        </div>
        <button id="scroll-to-top-btn">≫</button>
    </body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autoloader/prism-autoloader.min.js
    "></script>
    <script src="js/topButton.js"></script>
</html>