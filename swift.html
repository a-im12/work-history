<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Swift</title>
        <link rel="stylesheet" href="style/style.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism-okaidia.min.css">
    </head>
    <body>
        <div class="header">
            <!-- そのページの概要 -->
            <h1 class="page-title">~~ Swift ~~</h1>
            <a class="top-link" href="index.html">Back to Top</a>
        </div>
        <div class="main">
            <h3>links</h3>
            <div class="links">
                <ol>
                    <!-- ページ内リンク -->
                    <li><a href="#1">変数</a></li>
                    <li><a href="#2">定数</li>
                    <li><a href="#3">基本的な型</a></li>
                    <li><a href="#4">Optinal型</a></li>
                    <li><a href="#5">型のキャスト</a></li>
                    <li><a href="#6">リスト</a></li>
                    <li><a href="#7">辞書</a></li>
                    <li><a href="#8">範囲</a></li>
                    <li><a href="#9">if文</a></li>
                    <li><a href="#10">for文</a></li>
                </ol>
            </div>
            <br>
            <br>
            <br>
            <!-- コンテンツ -->
            <div class="contents" id="1">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">変数</h2>
                <p>
                    変数とは値を保存するための箱のようなもので、変数に値を入れることで
                    値を再利用できます。<br>
                    また、Swiftは<span style="font-size: 1.1em; color: black;">静的型付け言語</span>のため、
                    型宣言時に<a href="#3">型</a>を指定してあげなくてはいけません。
                    その変数の型に一致しない値を代入しようとした場合、コンパイルエラーとなってしまいます。
                    一方で変数に静的な型は存在せず、代入された値によってその変数の型が決まる言語のことを
                    <span style="font-size: 1.1em; color: black;">動的型付け言語</span>といい、代表的なものではPythonが挙げられます。
                </p>
                <p>具体的な宣言方法</p>
                <pre><code class="language-javascript">
// var 変数名:型 = 値
var num:Int = 10
                </code></pre>
                <p>
                    また、変数や<a href="#2">定数</a>の宣言時に型を宣言しなくても、<span style="font-size: 1.1em; color: black;">型推論</span>
                    という機能によって自動的に型が振り分けられます。<br>
                    しかし、型推論を利用するためには、変数宣言時に値を代入している必要があります。
                </p>
                <p>
                    ここでは、Int型の変数numを宣言しています。<br>
                    型については後で触れています。<br>
                </p>
                <p>その他の変数同士の演算や、代入、などは割愛します。</p>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="2">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">定数</h2>
                <p>
                    定数とはほとんど<a href="#1">変数</a>と同じ機能を持っています。
                    唯一違う点は、<span style="font-size: 1.1em; color: black;">再代入</span>できない
                    という違いです。一度値を持たされた定数に再度値を代入するとコンパイルエラーとなってしまいます。
                </p>
                <p>具体的な宣言方法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// let 定数名:型名 = 値
let num:Int = 12
                </code></pre>
                <p>ここでこの定数numに値を再代入すると...</p>
                <img src="img/teisuu.png" style="height:100%; width:100%;">
                <p>コンパイルエラーとなってしまいます。</p>

            </div>
            <!-- コンテンツ -->
            <div class="contents" id="3">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">基本的な型</h2>
                <p>Swiftが取り扱う基本的な型は以下の通りです。</p>
                <table style="margin-left: 50px;">
                    <tr>
                        <th>型名</th><th>概要</th>
                    </tr>
                    <tr>
                        <td><a href="#1_1">Int</a></td><td>整数値を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_2">String</a></td><td>文字列を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_3">Double</a></td><td>64ビット浮動小数値を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_4">Float</a></td><td>32ビット浮動小数値を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_5">Boolean</a></td><td>真偽値を扱う</td>
                    </tr>
                    <tr>
                        <td><a href="#1_6">Any</a></td><td>全ての値を扱う</td>
                    </tr>
                </table>
                <p>
                    概要に書いてあるとおり、それぞれで扱うことのできる値が変わってきます。
                    またそれぞれの型にOptional型というものがあり、詳しくは次のセクションで
                    解説しています。
                </p>
                <p>
                    その値が何の型なのかを調べるときには
                </p>
                <pre><code class="language-javascript">
print(type(of: 任意の値))
                </code></pre>
                <p>を実行することで、その値の型を調べることができます。</p>
                <p>結果↓</p>
                <div class="code-result">
                    <img src="img/type.png" style="height: 50%; width: 50%;">
                </div>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="4">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">Optional型</h2>
                <p>
                    Optional型とは何も値が入っていない状態(nil値)を許容する型です。
                    通常の型にnil値を入れるとコンパイルエラーとなってしまうため、
                    nil値が入ると思われるところに使用します。
                </p>
                <p>
                    Optional型として<a href="#1">変数</a>・<a href="#2">定数</a>を宣言する場合は
                    Optinal&lt;型名&gt;もしくは型名?とすることで宣言できます。
                </p>
                <p>具体的な宣言方法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var optionalNum:Optional&lt;Int&gt; = 12
let optionalStr:String? = nil
                </code></pre>
                <p>
                    ただしOptional型はnil値を許容しているため、演算をすることができません。
                    そこで、演算を行うためにはOptional型から値を取り出す<span style="font-size: 1.1em; color: black;">アンラップ</span>
                    を行う必要があります。
                </p>
                <p>アンラップの方法には以下の3つがあります。</p>
                <ul>
                    <li>if-let文を使ったアンラップ</li>
                    <li>??演算子を使ったアンラップ</li>
                    <li>強制アンラップ</li>
                </ul>
                <br>
                <h3>if-let文を使ったアンラップ</h3>
                <p>
                    if-let分を使用することでOptional型をアンラップすることができます。
                </p>
                <p>文法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
let opInt:Optional&lt;Int&gt; = 12

// if let 変数名 = Optional型の変数
if let int = opInt{
    // アンラップ成功時に実行したい処理
}
                </code></pre>
                <p>
                    ここでアンラップした先の変数intのスコープはif-let文内となるため、文の外では利用できません。<br>
                    (スコープとはその変数にアクセスできる範囲のこと)
                </p>
                <p>
                    また、通常の<a href="#9">if文</a>と同じく、文末にelseを追加することで、アンラップに失敗したときの処理を
                    追加することができます。
                </p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
let opStr:Optional&lt;String&gt; = nil

if let str = opStr{
    // アンラップ成功時の処理
}else{
    // アンラップ失敗時の処理
}
                </code></pre>
                <br>
                <h3>??演算子を使ったアンラップ</h3>
                <p>
                    アンラップ先の変数・定数宣言時に??演算子を用いることでアンラップを行うことができます。
                </p>
                <p>文法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var opInt:Optional&lt;Int&gt; = 12
// var 変数名:型名 Optional型の変数 ?? アンラップしたい型の具体的な値 
var int:Int = opInt ?? 0
print(int)  // 12

opInt = nil
int = opInt ?? 100
print(int)  //100
                </code></pre>
                <p>
                    ??演算子を使ったアンラップは、Optional型の値がnil値でない場合は
                    アンラップされた値が代入され、nil値の場合は??演算子のうしろについている
                    具体的な値が代入されます。これにより、代入先にnil値が入らないことを
                    保証しています。
                </p>
                <br>
                <h3>強制アンラップ</h3>
                <p>
                    強制アンラップとは、Optioanl型にnil値が入っている状態を考えず、すぐに
                    アンラップを行う手法です。<br>
                    強制アンラップはOptional型の変数の後ろに「!」をつけることで行えます。
                </p>
                <p>文法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var a:Optional&lt;Int&gt; = 12
var b:Optional&lt;Int&gt; = 2

print(a! + b!)  //14
                </code></pre>
                <p>
                    このように、Optional型の変数から直接値を取り出せます。<span style="font-size: 1.1em; color: black;">しかし</span>
                    この方法はOptional型の変数がnil値だった場合エラーとなる危険性があるので、使う場面をより慎重に考え、
                    適切に使用しなければなりません。乱用は避けましょう。
                </p>
                <p>nil値が入っているときに、強制アンラップを行った場合</p>
                <!-- 画像を入れる -->
                <img>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="5">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">型のキャスト</h2>
                <p>
                    キャストとは現在の型を別の型として扱う手法のことを言い、
                    <span style="font-size: 1.1em; color: black;">アップキャスト</span>と
                    <span style="font-size: 1.1em; color: black;">ダウンキャスト</span>の二つがある。
                </p>
                <br>
                <h3>アップキャスト</h3>
                <p>
                    アップキャストとは階層関係にある具体的な値を、上位の抽象的な値に変換することを言う。
                    キャストには「as」を使用する。
                </p>
                <p>文法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var str:String = "aaa"      // 具体的な型(String)
var any:Any = str as Any    // 上位の抽象的な型(Any)
                </code></pre>
                <h3>ダウンキャスト</h3>
                <p>
                    もう一つのダウンキャストは、アップキャストとは反対に上位の抽象的な
                    型を下位の具体的な型に変換することを言います。また、ダウンキャストされた値は
                    オプショナル型となる。キャストには「as?」「as!」を使用する。
                    しかし、「as!」はダウンキャストと同時に<span style="font-size: 1.1em; color: black;">強制アンラップ</span>を行うため、
                    キャスト元にnil値が入っているとエラーとなる。扱いには注意が必要。
                </p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
var any:Any = 12                // 抽象的な型
var opInt:Int? = any as? Int?   // Optinal(12)

any = nil

opInt = any as? Int?            //nil
var int:Int = any as! Int       // キャストもとにnil値が入っているのでエラー
                </code></pre>
            </div>
            <!-- コンテンツ -->
            <div class="contents" id="6">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">配列</h2>
                <p>
                    配列とは、変数の寄せ集めのような構造のデータ。
                    使用方法はPythonやほかの言語と大差ないが、宣言方法が独特である。
                    <a href="#10">for文</a>と組み合わせて使用することもできる。
                    Optional型として宣言することも可能。
                </p>
                <p>具体的な宣言方法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名:Array&lt;任意の型名&gt; = [値, 値, 値.....]
var numArray:Array&lt;Int&gt; = [1, 2, 3, 4, 5, 6]

print(numArray[2])  // 3
                </code></pre>
                <p>他にも「追加」「挿入」「結合」「削除」が可能。</p>
                <br>
                <h3>追加</h3>
                <p>配列.append(値)で指定した配列に値を追加することができる。</p>
                <p>文法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 配列.append(値)
var opStrArray:Array&lt;String?&gt; = ["A", "B", "C", "E"]
opStrArray.append(nil)  // ["A", "B", "C", "E", nil]
                </code></pre>
                <br>
                <h3>挿入</h3>
                <p>配列.insert(値, at:インデックス)で、指定した配列の指定したインデックスに値を追加することができる。</p>
                <p>文法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 配列.insert(値, at:インデックス)
var anyArray:Array&lt;Any&gt; = [1, "aa", 1.5, True]
anyArray.insert(2, at:1)    // [1, 2, "aa", 1.5, True]
                </code></pre>
                <br>
                <h3>結合</h3>
                <p>
                    配列 + 配列とすることで配列同士を結合することができる。感覚的には文字列結合に近い<br>
                    ※型は統一されていないとエラーとなる。
                </p>
                <p>文法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 配列 + 配列
var array1 = [1, 2, 3, 4]
var array2 = [6, 7, 8, 9]

var array3 = array1 + array2
print(arrray3)  // [1, 2, 3, 4, 6, 7, 8, 9]
                </code></pre>
                <br>
                <h3>削除</h3>
                <p>配列.remove(at:インデックス)とすることで指定した配列の指定したインデックスの値を削除することができる。</p>
                <p>文法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 配列.remove(at:インデックス)
var opIntArray: Array&lt;Optional&lt;Int&gt;&gt; = [1, 2, nil, 4]
opIntArray.remove(at: 2)    // [1, 2, 4]
                </code></pre>
            </div>
            <div class="contents" id="7">
                <!-- コンテンツタイトル -->
                <h2 class="contents-title">辞書</h2>
                <p>
                    辞書とは、キーとそのキーに対応した値を集めたデータのことを言う。

                </p>
                <p>具体的な宣言方法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// var 変数名:Dictionaly&lt;キーの型, 値の型&gt; = [キー:値, キー:値, キー:値...]
var dict:Dictionaly&lt;Int, String&gt; = [1 : "佐藤", 2 : "鈴木", 3 : "田中"]
                </code></pre>
                <p>
                    辞書のキーを指定することで、それに対応した値を取り出すことができる。
                    この取り出した値は、<a href="#4">Optional型</a>となって返ってくる。また、存在しない
                    キーを指定した場合は、nil値が返ってくる。Optional型である理由は
                    ここにあるのかもしれない。

                </p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 辞書名[キー]
var dict:Dictionaly&lt;Int, String&gt; = [1 : "佐藤", 2 : "鈴木", 3 : "田中"]

var opName:Optional&lt;String&gt;
opName = dict[2]     // Optional("鈴木")
opName = dict[9]     // nil
                </code></pre>
                <p>また、辞書にも「追加」「更新」「削除」の機能がある。</p>
                <br>
                <h3>追加</h3>
                <p>値を追加したい場合は存在しないキーに値を代入する。</p>
                <p>文法</p>
                <!-- プログラムソースの埋め込み -->
                <pre><code class="language-javascript">
// 辞書名[存在しないキー] = 追加したい値
var dict:Dictionaly&lt;Int, String&gt; = [1 : "佐藤", 2 : "鈴木", 3 : "田中"]

dict[4] = "高橋"
print(dict)     // [1 : "佐藤", 2 : "鈴木", 3 : "田中", 4 : "高橋"]
                </code></pre>
                <br>
                <h3>更新</h3>
                <p></p>
            </div>
        </div>
        <div class="footer">
            <p>
                荒川 歩夢<br>
                ayumu arakawa
            </p>
            <br>
            <p>
                KCS鹿児島情報専門学校 / 北海道情報大学通信教育部経営情報学部システム情報科<br>
                出身地 : 鹿児島
            </p>
            <p><a href="https://github.com/a-im12" style="color: white;">github : a-im12</a></p>
        </div>
    </body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autoloader/prism-autoloader.min.js
    "></script>
</html>